from .configuration import SourceConfiguration
from .snr import get_sensor_space_variance, adjust_snr
from .sources import _combine_sources_into_stc
from .source_groups import PointSourceGroup
from .waveform import one_over_f_noise


class SourceSimulator:
    """
    This class can be used to create a source configuration by adding 
    point sources (e.g., of narrowband oscillatory activity or 1/f noise.)

    Attributes
    ----------
    src: mne.SourceSpaces
        The source space that contains all candidate source locations.
    """

    def __init__(self, src):
        self.src = src
                       
        # Store groups of sources that were defined with one command
        # Store 'signal' and 'noise' separately to ease the calculation of SNR
        self._source_groups = []
        self._noise_groups = []

        # Keep track of all added sources to check name conflicts
        self._sources = []

        # Store all coupling edges
        self._coupling = {}

        # Keep track whether SNR of any source should be adjusted
        # If yes, then a forward model is required for simulation
        self.is_snr_adjusted = False

    def add_point_sources(
        self, 
        location, 
        waveform, 
        snr=None,
        location_params=dict(), 
        waveform_params=dict(),
        snr_params=dict(),
        names=None
    ):
        """
        Add point sources to the simulation.

        Parameters
        ----------
        location: list or callable
            Locations of sources can be either specified directly as a list of tuples
            (index of the src, vertno) or as a function that returns such a list.
            In the first case, source locations will be the same for every configuration,
            while in the second configurations might differ (e.g., if the function 
            returns a random location).
        waveform: np.array or callable
            Waveforms of source activity provided either directly in an array (fixed
            for every configuration) or as a function that generates the waveforms
            (but differ between configurations if the generation is random). 
        snr: None (do not adjust SNR), float (same SNR for all sources), or array (one value per source)
            TODO: fix when finalizing SNR
            NB: only positive values make sense, raise error if negative ones are provided
        location_params: dict, optional
            Keyword arguments that will be passed to the location function.
        waveform_params: dict, optional
            Keyword arguments that will be passed to the waveform function.
        snr_params: dict, optional
            TODO: fix when finalizing SNR
            fmin and fmax for the frequency band that will be used to adjust SNR.
        names: list, optional
            A list of names for each source. If not specified, the names will be
            autogenerated using the format 'sgN-sM', where N is the index of the
            source group, and M is the index of the source in the group.
        
        Returns
        -------
        names: list
            A list of (provided or autogenerated) names for each source
        """
            
        next_group_idx = len(self._source_groups)
        point_sg = PointSourceGroup.create(
            self.src,
            location, 
            waveform, 
            snr=snr,
            location_params=location_params,
            waveform_params=waveform_params,
            snr_params=snr_params,
            names=names,
            group=f'sg{next_group_idx}',
            existing=self._sources
        )
                
        # Store the source group and source names
        self._source_groups.append(point_sg)
        self._sources.extend(point_sg.names)
        
        # Check if SNR should be adjusted
        if point_sg.snr is not None:
            self.is_snr_adjusted = True

        # Return the names of newly added sources
        return point_sg.names
        
    # def add_patch_sources(self, location, waveform, snr=None, patch_corr=None, 
    #                     location_params=None, waveform_params=None, grow_params=None, names=None):
    #     """
    #     Parameters
    #     ----------
    #     patch_corr: None or float between 0 and 1
    #         if None, all vertices contain the same signal
    #         otherwise, all vertices contain the same signal plus noise
    #         NB: probably lower priority for now
    #     """

    def add_noise_sources(
        self, 
        location, 
        waveform=one_over_f_noise, 
        location_params=dict(), 
        waveform_params=dict(),
    ):
        """
        Add noise sources to the simulation. If an adjustment of SNR is needed at
        some point, these sources will be considered as noise.

        Parameters
        ----------
        location: list or callable
            Locations of sources can be either specified directly as a list of tuples
            (index of the src, vertno) or as a function that returns such a list.
            In the first case, source locations will be the same for every configuration,
            while in the second configurations might differ (e.g., if the function 
            returns a random location).
        waveform: np.array or callable
            Waveform provided either directly as an array or as a function.
            By default, 1/f noise is used for all noise sources.
        location_params: dict, optional
            Additional arguments that will be provided to the location function.
            Ignored if location is a list of vertices.
        waveform_params: dict, optional
            Additional arguments that will be provided to the waveform function.
            Ignored if waveform is an array.

        Returns
        -------
        names: list
            Autogenerated names for the noise sources. The format is 'ngN-sM', 
            where N is the index of the noise source group, and M is the index 
            of the source in the group.

        Notes
        -----
        Noise patches are not supported.
        """
        
        next_group_idx = len(self._noise_groups)
        noise_sg = PointSourceGroup.create(
            self.src,
            location,
            waveform, 
            snr=None, 
            location_params=location_params,
            waveform_params=waveform_params,
            snr_params=dict(),
            names=None,
            group=f'ng{next_group_idx}',
            existing=self._sources
        )

        # Store the new source group and source names
        self._noise_groups.append(noise_sg)
        self._sources.extend(noise_sg.names)
        
        # Return the names of newly added sources
        return noise_sg.names
        
    def set_coupling(self, coupling, method):
        raise NotImplementedError('Coupling is not supported yet')
        # coupling = check_coupling(coupling, method)
        # self._coupling.update(coupling)
        
    def simulate(
        self,  
        sfreq, 
        duration,
        fwd=None,
        random_state=None
    ):
        if not (self._source_groups or self._noise_groups):
            raise ValueError('No sources were added to the configuration.')

        if self.is_snr_adjusted and fwd is None:
            raise ValueError('A forward model is required for the adjustment '
                             'of SNR.')

        return _simulate(
            self._source_groups,
            self._noise_groups,
            self.src,
            sfreq,
            duration,
            fwd=fwd,
            random_state=random_state
        )


def _simulate(
    source_groups, 
    noise_groups,
    src,
    sfreq,
    duration,
    fwd,
    random_state=None
):
    """
    This function describes the simulation workflow.
    """
    # Initialize the SourceConfiguration
    sc = SourceConfiguration(src, sfreq, duration, random_state=random_state)

    # Simulate all sources independently first (no coupling yet)
    noise_sources = []
    for ng in noise_groups:
        noise_sources.extend(ng.simulate(src, sc.times, random_state=random_state))
    noise_sources = {s.name: s for s in noise_sources}

    sources = []
    for sg in source_groups:
        sources.extend(sg.simulate(src, sc.times, random_state=random_state))
    sources = {s.name: s for s in sources}

    # Setup the desired coupling patterns
    # The time courses are changed for some of the sources in the process

        # Here we should also check for possible cycles in the coupling structure
        # If there are cycles, raise an error
        # If there are no cycles, traverse the graph and set coupling according to the selected method
        # Try calling the coupling with the provided parameters but be prepared for mismatches

    # Get the stc and leadfield of all noise sources
    stc_noise = _combine_sources_into_stc(noise_sources.values(), src)

    # Adjust the SNR of sources in each source group
    for sg in source_groups:
        if sg.snr is None:
            continue

        # Estimate the noise variance in the specified frequency band
        fmin, fmax = sg.snr_params['fmin'], sg.snr_params['fmax']
        noise_var = get_sensor_space_variance(stc_noise, fwd, 
                                              fmin=fmin, fmax=fmax, filter=True)
        
        # Adjust the amplitude of each source in the group to match the target SNR
        for name, target_snr in zip(sg.names, sg.snr):
            s = sources[name]

            # NOTE: taking a safer approach for now and filtering
            # even if the signal is already a narrowband oscillation
            signal_var = get_sensor_space_variance(s.to_stc(src), fwd,
                                                   fmin=fmin, fmax=fmax, filter=True)

            # NOTE: patch sources might require more complex calculations
            # if the within-patch correlation is not equal to 1
            amp = adjust_snr(signal_var, noise_var, target_snr)
            s.waveform *= amp

    # Add the sources to the simulated configuration
    sc._sources = sources
    sc._noise_sources = noise_sources

    return sc
