from ._check import check_coupling
from .configuration import SourceConfiguration
from .source_groups import _create_point_source_group
from .waveform import one_over_f_noise


class SourceSimulator:
    """
    Generates SourceConfiguration objects according to the provided input.
    """

    def __init__(self, src):
        self.src = src
                       
        # Store groups of sources that were defined with one command
        # Store 'signal' and 'noise' separately to ease the calculation of SNR
        self._source_groups = []
        self._noise_groups = []

        # Keep track of all added sources to check name conflicts
        self._sources = []

        # Store all coupling edges
        self._coupling = {}

    def __contains__(self, name):
        return (name in self._sources or name in self._noise_sources)

    def add_point_sources(
        self, 
        location, 
        waveform, 
        snr=None,
        location_params=dict(), 
        waveform_params=dict(),
        snr_params=dict(),
        names=None
    ):
        """
        Parameters
        ----------
        location: list of vertices (should match the format of src) or a callable
        
        waveform:
            Q: should we allow passing an array directly?
            Q: don't set a default waveform here to make user explicitly choose it? or just generate alpha by default?
        
        snr: None (do not adjust SNR), float (same SNR for all sources), or array (one value per source)
            NB: only positive values make sense, raise error if negative ones are provided
        
        location_params: None or dict
            Keyword arguments that will passed to the location function.
        
        waveform_params: None or dict
            Keyword arguments that will passed to the waveform function.
        
        snr_params: dict
            fmin and fmax for the frequency band that will be used to adjust SNR.

        names: None or list
            A list of names for each source
        
        Returns
        -------
        names: list
            A list of (provided or autogenerated) names for each source
        """
            
        next_group_idx = len(self._source_groups)
        point_sg, names = _create_point_source_group(
            self.src,
            location, 
            waveform, 
            snr=snr,
            location_params=location_params,
            waveform_params=waveform_params,
            snr_params=snr_params,
            names=names,
            group=f'sg{next_group_idx}',
            existing=self._sources
        )
                
        # Store the source group and source names
        self._source_groups.append(point_sg)
        self._sources.extend(names)
        
        # Return the names of newly added sources
        return names
        
    # def add_patch_sources(self, location, waveform, snr=None, patch_corr=None, 
    #                     location_params=None, waveform_params=None, grow_params=None, names=None):
    #     """
    #     Parameters
    #     ----------
    #     patch_corr: None or float between 0 and 1
    #         if None, all vertices contain the same signal
    #         otherwise, all vertices contain the same signal plus noise
    #         NB: probably lower priority for now
    #     """

    def add_noise_sources(
        self, 
        location, 
        waveform=one_over_f_noise, 
        location_params=dict(), 
        waveform_params=dict(),
    ):
        """
        Parameters
        ----------
        location: 
        waveform: ndarray or callable
            Waveform provided either directly as an array or as a function.
            By default, 1/f noise is used for all noise sources.
        location_params: dict, optional
            Additional arguments that will provided to the location function.
            Ignored if location is a list of vertices.
        waveform_params: dict, optional
            Additional arguments that will provided to the waveform function.
            Ignored if waveform is an array.

        Notes
        -----
        Noise patches are not supported.
        """
        
        next_group_idx = len(self._noise_groups)
        noise_sg, names = _create_point_source_group(
            self.src,
            location,
            waveform, 
            snr=None, 
            location_params=location_params,
            waveform_params=waveform_params,
            snr_params=dict(),
            names=None,
            group=f'ng{next_group_idx}',
            existing=self._sources
        )

        # Store the new source group and source names
        self._noise_groups.append(noise_sg)
        self._sources.extend(names)
        
        # Return the names of newly added sources
        return names
        
    def set_coupling(self, coupling, method):
        raise NotImplementedError('Coupling is not supported yet')
        # coupling = check_coupling(coupling, method)
        # self._coupling.update(coupling)
        
    def simulate(
        self,  
        sfreq, 
        duration, 
        src=None,
        fwd=None,
        random_state=None
    ):
        # Parameters:
        # -----------
        #   scaling_factor: float
        #   All source time courses get multiplied by this number before projecting to sensor space.
        #   It looks a bit random in Mina's codes so I think we should attach some physical meaning (e.g., X nA/m) to it.
        
        return _simulate(
            self._source_groups,
            self._noise_groups,
            self._coupling,
            src,
            sfreq,
            duration,
            random_state=random_state
        )


def _simulate(
    source_groups, 
    noise_groups,
    coupling,
    src,
    sfreq,
    duration,
    random_state
):
    """
    This function describes the simulation workflow.
    """
    # INIT
    sc = SourceConfiguration(src, sfreq, duration, random_state)

    # Simulate noise sources first (important for adjusting the SNR)
    noise_sources = {}
    for ng in noise_groups:
        sources = ng.simulate(src, sc.times)
        noise_sources.update({s.name: s for s in sources})

    # COUPLING
    # Here we should also check for possible cycles in the coupling structure
    # If there are cycles, raise an error
    # If there are no cycles, traverse the graph and set coupling according to the selected method
    # Try calling the coupling with the provided parameters but be prepared for mismatches

    # SNR
    # fwd_noise = mne.forward.restrict_forward_to_stc(fwd, stc_noise, on_missing='raise')    
    # noise_var = get_sensor_space_variance()
    # Here we should also adjust the SNR
    # 2. Adjust the amplitude of each signal source (self._sources) according to the desired SNR (if not None)

    return sc
