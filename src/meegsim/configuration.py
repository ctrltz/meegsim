import numpy as np
import mne

from .coupling import COUPLING_FUNCTIONS
from .snr import get_sensor_space_variance
from .sources import _create_point_sources
from .utils import combine_sources_into_stc, combine_stcs
from .waveform import one_over_f_noise


class SourceConfiguration:
    """
    Defines a configuration of sources of brain activity and noise.

    Attributes:
    -----------
    src: mne.SourceSpaces
        Source spaces object that stores all candidate source locations.

    sfreq: float
        Sampling frequency of the simulated data, in Hz.

    duration: float
        Length of the simulated data, in seconds.
    """

    # Still need to be added somewhere:
    #  * subject, subjects_dir - might be required by label.center_of_mass
    #    (we could pass as additional arguments to the location function)
    # Q: is `src` in theory subject-specific? need more experience with individual MRI analyses
    #
    # Other ideas:
    #  * saving a configuration
    #  * plotting a configuration with different source groups highlighted in
    #    different colors

    def __init__(self, src, sfreq, duration, random_state=None):
        self.src = src
        
        # Simulation parameters
        self.sfreq = sfreq
        self.duration = duration
        self.n_samples = self.sfreq * self.duration
        self.times = np.arange(self.n_samples) / self.sfreq
        
        # Random state (for reproducibility)
        self.random_state = random_state
        
        # Keep track of all added sources, store 'signal' and 'noise' separately to ease the calculation of SNR
        self._sources = {}
        self._noise_sources = {}
        
        # Define groups of sources that were defined with one command (should allow reducing the computation)
        self._source_groups = []

        # Track whether SNR was adjusted for any source
        # Once SNR was adjusted, it is not allowed to add other noise sources
        self.adjusted_snr = False

    def add_point_sources(
        self, 
        location, 
        waveform, 
        snr=None,
        fwd=None, 
        location_params=dict(), 
        waveform_params=dict(),
        snr_params=None,
        names=None
    ):
        """
        Parameters
        ----------
        location: list of vertices (should match the format of src) or a callable
        
        waveform:
            Q: should we allow passing an array directly?
            Q: don't set a default waveform here to make user explicitly choose it? or just generate alpha by default?
        
        snr: None (do not adjust SNR), float (same SNR for all sources), or array (one value per source)
            NB: only positive values make sense, raise error if negative ones are provided
        
        location_params: None or dict
            Keyword arguments that will passed to the location function.
        
        waveform_params: None or dict
            Keyword arguments that will passed to the waveform function.
        
        names: None or list
            A list of names for each source
        
        Returns
        -------
        names: list
            A list of (provided or autogenerated) names for each source
        """
        
        # TODO: check the names are unique, not empty and do not yet exist in the structure
        # autogenerate if needed (potential format: sg{index of the source group}-src{index of the src}-{vertno})
        # what if custom location functions produce non-unique values? we might need to warn the user or forbid it
        
        if snr is not None:
            raise NotImplementedError('Adjustment of SNR is not yet supported')
            # Check that fwd was provided
            # Combine all noise sources
            # fwd_noise = mne.forward.restrict_forward_to_stc(fwd, stc_noise, on_missing='raise')    
            # noise_var = get_sensor_space_variance()

        next_group_idx = len(self._source_groups)
        point_sources = _create_point_sources(
            self.src,
            self.times, 
            location, 
            waveform, 
            snr=snr,
            location_params=location_params,
            waveform_params=waveform_params, 
            random_state=self.random_state,
            names=names,
            name_prefix=f'sg{next_group_idx}-'
        )
        self._sources.update(point_sources)
                
        # Mark that the newly generated sources can be processed together (for example, when adjusting SNR)
        current_group = list(point_sources.keys())
        self._source_groups.append(current_group)
        
        # Return the names of newly added sources
        return current_group
        
    # def add_patch_sources(self, location, waveform, snr=None, patch_corr=None, 
    #                     location_params=None, waveform_params=None, grow_params=None, names=None):
    #     """
    #     Parameters
    #     ----------
    #     patch_corr: None or float between 0 and 1
    #         if None, all vertices contain the same signal
    #         otherwise, all vertices contain the same signal plus noise
    #         NB: probably lower priority for now
    #     """

    def add_noise_sources(
        self, 
        location, 
        waveform=one_over_f_noise, 
        location_params=dict(), 
        waveform_params=dict(),
    ):
        """
        Parameters
        ----------
        location: 
        waveform: ndarray or callable
            Waveform provided either directly as an array or as a function.
            By default, 1/f noise is used for all noise sources.
        location_params: dict, optional
            Additional arguments that will provided to the location function.
            Ignored if location is a list of vertices.
        waveform_params: dict, optional
            Additional arguments that will provided to the waveform function.
            Ignored if waveform is an array.

        Notes
        -----
        Currently, all noise sources should be added to the configuration prior
        to adding sources whose SNR should be adjusted. Also, noise patches are
        not supported.
        """
        
        # Block addition of noise sources once we adjusted SNR
        if self.adjusted_snr:
            raise RuntimeError('SNR was adjusted for one of sources, '
                               'adding noise sources is not allowed')

        noise_sources = _create_point_sources(
            self.src,
            self.times,
            location,
            waveform, 
            snr=None, 
            location_params=location_params,
            waveform_params=waveform_params,
            random_state=self.random_state,
            names=None,
            name_prefix='ng-'
        )
        self._noise_sources.update(noise_sources)
        
        # Return the names of newly added sources
        return list(noise_sources.keys())

    def check_if_exist(self, names):
        missing = [name for name in names if name not in self._sources]
        if missing:
            raise ValueError(f"The configuration contains no sources with the following names: {', '.join(missing)}")

    def get_waveforms(self, names):
        self.check_if_exist(names)
        waveforms = [self._sources[name].waveform for name in names]
        return np.vstack(waveforms)

    def set_coupling(self, coupling, coupling_fun):
        # Here we should also check for possible cycles in the coupling structure
        # If there are cycles, raise an error
        # If there are no cycles, traverse the graph and set coupling according to the selected method
        # Try calling the coupling with the provided parameters but be prepared for mismatches
        
        # For now, only consider the case of one connection
        if len(coupling) > 1:
            raise NotImplementedError('This function currently does not support adding more than one connection at a time')
                
        # Use the first (and the only) element in the dictionary
        coupling_edge = list(coupling.keys())[0]
        coupling_params = list(coupling.values())[0]
        name1, name2 = coupling_edge[0]
        self.check_if_exist([name1, name2])
        
        # Get the corresponding sources
        s1, s2 = self._sources[name1], self._sources[name2]
        
        # Update the time series of s2 to be coupled to the time series of s1 in a desired way
        # Ideally, this part should not depend on whether we are working with a point source or a patch
        s2.waveform = coupling_fun(s1.waveform, random_state=self.random_state, **coupling_params)

    def simulate_raw(self, fwd, info, scaling_factor=1e-6, return_stc=False):
        # Parameters:
        # -----------
        #   scaling_factor: float
        #   All source time courses get multiplied by this number before projecting to sensor space.
        #   It looks a bit random in Mina's codes so I think we should attach some physical meaning (e.g., X nA/m) to it.
        
        # Combine all noise sources
        stc_noise = self._combine_noise_sources_to_stc()

        # Combine all sources into one stc
        stc_combined = stc_noise
        for sg in self._source_groups:
            group_sources = [self._sources[name] for name in sg]
            
            # XXX: might need to provide subject as well
            stc_group = combine_sources_into_stc(group_sources, self.src, self.sfreq)
            stc_combined = combine_stcs(stc_noise, stc_group)

        # Multiply the resulting stc by the scaling factor
        stc_combined *= scaling_factor
    
        # Project to sensor space and return
        raw = mne.apply_forward_raw(fwd, stc_combined, info)
        
        # TODO: add sensor space noise (white noise by default but allow customizing?)
        
        if return_stc:
            return raw, stc_combined
                
        return raw

    def _combine_noise_sources_to_stc(self):
        noise_sources = list(self._noise_sources.values())
        # XXX: might need to provide subject as well
        return combine_sources_into_stc(noise_sources, self.src, self.sfreq)